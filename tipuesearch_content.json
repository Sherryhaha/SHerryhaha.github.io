{"pages":[{"url":"http://sherryhaha.github.io/ping-jie-you-shi-yong-de-hu-fu-pin-fen-xiang/","text":"预算很充足的妹子不需要看此文哈，尽管朝着cpb，hoo等贵妇级产品看齐。本文主要分享［洁面］［护肤］［护发］［淡妆］四个方面，持续更新...... 本文图片都是从淘宝上截的图，懒人一枚，没有拍实图，有些图后期会补上 洁面 - 卸妆： ￼￼ 美宝莲眼唇卸妆液 ，由于我平时也从未画过浓妆，这个卸妆液对我来说就够了，当我没钱时我就买这个，因为经常有活动买一送一什么的，超级划算。不足点就是这个卸妆液水油分离的太快，每次我摇匀了过一会会儿就分开了。 贝德玛卸妆水 ，最近最爱的卸妆水，我用的是蓝水，听说粉水更加温和，敏感肌的朋友可以考虑粉水，对我来说蓝水就很好，卸妆力度很好，500ml一大瓶也够用好久。用这个卸妆水擦完后脸上很润，味道也很好闻。 - 洗面奶： 没钱时我就会买 美丽加芬 ，泡沫细腻丰富，洗完也觉得挺赶紧不紧绷，总之性价比超高，也经常搞活动买一送一，因为洗面之前不管化妆没有，我都会用卸妆液，所以对于洗面奶的要求我比较低，只要补水洗的干净就行。 护肤 - 面膜： 森田 保湿补水，相对于美丽日记等同价位的面膜好用很多。注意购买台版的。 曼丹婴儿娃娃脸宝宝面膜 ，日本的一款面膜没有味道，没有味道，这几乎是我选护肤品的一大前提，很润，精华多。 可莱丝水库面膜 ：韩国的一款面膜，很水润，面膜的贴合性很好。然而10元一片的补水面膜我觉得性价比并不高。 - 爽肤水： Esthe Dew 胎盘美白 保湿修复化妆水 蓝色是美白，红色主要针对补水，500ml一大瓶，用来做水膜很好，当我实在买不起化妆水时，这个也充当我的化妆水，每次洗完脸后，我都会用它擦一遍脸，当清洁水用，性价比之王绝对。 minon化妆水 ：适合于敏感肌，当然非敏感肌也可以用，保湿效果一级棒。推荐有预算的一定要买，除非你是超级大油皮，那么自己慎重。 雪肌精化妆水 ：酒精味确实很浓，用的时间较短，没有感觉到它的美白祛斑功效，干到是真的，干皮的妹子要做好保湿工作。 - 乳液 minon乳液 ：味道很淡，跟它的水差不多，很好闻，质感很好，不是那种很稀的乳液，感觉特别保湿，也有柔肤的功效的感觉，强烈推荐。 SANA乳液 ：有淡淡的酒精味，相对于minon来说，稀很多，刚涂上脸会觉得不是很吸收，多按摩几下就好了，吸收完后脸很柔软。 - 精华 乐敦 vc cc美白精华 ：精华都超贵的，这个我也是看便宜，用着玩的，味道是淡淡的柠檬味，质地很好，用了后虽然不敢说淡斑，但是美白绝对有，至少要用一个月才能看出效果哦。 - 眼霜 FACE FEEL葡萄籽眼霜 ：非常非常好用的眼霜，好推开，质地柔和，然而后来我不知道哪里能买到了。。。 SANA眼霜 ：主要是补水，性价比高，好推开。 - 隔离 Poul&Jeo搪瓷隔离 ：被神化的很厉害，什么素颜神器之类的，挺好用的，但也确实没有那么神奇啦。能提亮肤色，有轻微的遮瑕功效，变白的功效几乎没有，确实很自然，不像抹了东西的，用了以后感觉看上去气色很好。 护发 the body shop 生姜去屑洗发水 ：我大概从高三开始用的清扬，一开始用了确实很好，但是后来头就特别的痒，我是偏干性发质，但是用了后几乎两天头就痒，头屑还巨多，掉头发什么的就不说了。换了这个洗发水后头皮屑和头痒得到了非常大的改善，现在基本5天不洗头没事＝＝，油头还有有头屑问题的人赶紧用起来啊～还有就是我现在掉发也没以前严重了，不知道是不是它的功劳。 LG润膏 ：韩国的产品，传说中的洗护合一，能使发质变好，我现在基本上是用完the body shop后再涂这个，因为这个味道有股淡香，再冲着它传说中的护发效果，我感觉虽然没有传说中神奇，但还是不错的。 淡妆 - 眉毛 资生堂自然眉笔 ：很小的一只，容易上色，性价比超高，一般来说，不会掉妆。 凯芙兰眉粉 ：从大一开始用的，用到现在都没有用掉，个人觉得很好用啊，上色容易，性价比也可以，一般到晚上都不会掉妆。 - 唇膏 canmake高保湿防晒持久滋润唇膏 ：绝对的水润保湿，涂上的感觉就想是唇膏，不黏腻（我真是受够了那些黏腻的唇膏唇彩balalaala），颜色很美，一般我会涂嘴中间一点然后用手点开。性价比较高 - 睫毛膏 the face shop大肚睫毛膏 ：真的真的非常好用，虽然我平时基本不会用睫毛膏，嫌麻烦，一天下来基本不会晕妆，很好卸，我就是用那个贝德玛卸的，因为我很少很少画眼部的妆，所以没有买专门的眼唇卸妆，性价比超高。","tags":"护肤","title":"平价又实用的护肤品分享"},{"url":"http://sherryhaha.github.io/wang-guan-deng-lu-jiao-ben/","text":"用python写了一个网关登陆脚本。 就是模拟网关登陆页面向服务器发送数据验证进行登陆。 代码如下： import base64 , requests , json , sys def logGateway (): url = 'http://a.suda.edu.cn/index.php/index/login' ＃ data1 是一个字典数组，存放用于发送给服务器的数据 data1 = {} #获取用户名与密码参数 uname = sys . argv[ 1 ] pword = sys . argv[ 2 ] ＃由于网关的页面对密码是进行 base64 加密后传输的，这里也要同样的模拟加密 modifyPassword = base64 . b64encode(pword) data1[ 'username' ] = uname data1[ 'password' ] = modifyPassword headers1 = { 'Host' : 'a.suda.edu.cn' , 'User-Agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:43.0) Gecko/20100101 Firefox/43.0' , 'Accept' : 'application/json, text/javascript, */*; q=0.01' , 'Accept-Language' : 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3' , 'Accept-Encoding' : 'gzip, deflate' , 'Content-Type' : 'application/x-www-form-urlencoded; charset=UTF-8' , 'X-Requested-With' : 'XMLHttpRequest' , 'Referer' : 'http://a.suda.edu.cn/index.php?url=aHR0cDovL3dnLnN1ZGEuZWR1LmNuLw==' , 'Content-Length' : '53' , 'Connection' : 'keep-alive' , } ＃向服务器端提交数据，返回的结果由 r 保存 r = requests . post(url, data = data1, headers = headers1) print r . text if __name__ == '__main__' : logGateway()","tags":"Python","title":"网关登陆脚本"},{"url":"http://sherryhaha.github.io/pat/","text":"@(刷题生活) 1002 A+B for Polynomials (25) 时间限制400 ms 内存限制65536 kB 代码长度限制16000 B This time, you are supposed to find A+B where A and B are two polynomials. 2 Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 <= K <= 10，0 <= NK < … < N2 < N1 <=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 /* 这题用了hash映射，将指数为Nk的系数映射到数组A[Nk]中。 */ #include<stdio.h> #define maxn 1024 //一开始我用的const int maxn=9;但是编译错误了,c里面好像是不能这么用设置成9并不能通过，要改成1024???为什么呢 //因为虽然1<=k<=10但k代表的是非0多项式的个数，所以总共不止k个 int main (){ double A[maxn] = { 0 },co =0 ; //给数组A赋值为全0 int k =0 ,k2 = 0 ,i =0 ,e =0 ; //输入第一个多项式 scanf( \"%d\" , & k); for (i = 0 ;i < k;i ++ ){ scanf( \"%d\" , & e); scanf( \"%lf\" , & A[e]); } //输入第二个多项式并进行相加运算 scanf( \"%d\" , & k); for (i = 0 ;i < k;i ++ ){ scanf( \"%d\" , & e); scanf( \"%lf\" , & co); A[e] = A[e] + co; //进行加法运算 } for (i = 0 ;i < maxn;i ++ ){ if (A[i] !=0 ) k2 ++ ; } printf( \"%d\" ,k2); //输出多项式中非0的项目个数 for (i = maxn -1 ;i >=0 ;i -- ){ if (A[i] !=0 ){ printf( \" %d %.1lf\" ,i,A[i]); } } return 0 ; } 1003 As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered(分散) cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (<= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input 5 6 0 2 1 2 1 5 3 0 1 1 0 2 2 0 3 1 1 2 1 2 4 1 3 4 1 Sample Output 2 4 /*这题是求图上的两点之间最短路径有几条。用深度优先来求。 */ #include<stdio.h> #include<limits.h> //为了用INT_MAX,表示整数的最大数值 #define MAX 1024 //声明全局变量 int count,max,predist,n,visit[MAX],dist[MAX][MAX],countTeam[MAX];; void dfs ( int start, int end, int d, int team); int main (){ int m,start,end,i,c1,c2,j,dis; predist = INT_MAX,count = 0 ; scanf( \"%d %d %d %d\" , & n, & m, & start, & end); for (i = 0 ;i < n;i ++ ){ scanf( \"%d\" , & countTeam[i]); } //初始化visit数组为0，dist数组为INT_MAX for (i = 0 ;i < n;i ++ ){ visit[i] = 0 ; for (j = 0 ;j < n;j ++ ){ dist[i][j] = INT_MAX; } } for (i = 0 ;i < m;i ++ ){ scanf( \"%d %d %d\" , & c1, & c2, & dis); if (dist[c1][c2] > dis){ dist[c1][c2] = dist[c2][c1] = dis; //这边注意，要将两个数组值都赋值 } } dfs(start,end, 0 ,countTeam[start]); printf( \"%d %d \\n \" ,count,max); return 0 ; } void dfs ( int p, int end, int d, int team){ //当已经达到最终的节点时，判断距离是否比已有的距离小，是的话就将最小距离的变量值改变，如果相等，就比较哪个队伍多，将队伍多的值付给现有的 //队伍最大值。 if (p == end){ if (d < predist){ count = 1 ; //输出有几条最短路径 predist = d; //predist一开始被赋值为INT_MAX max = team; } else if (d == predist){ count ++ ; if (team > max) max = team; } return ; } if (d > predist) return ; int i; //递归调用dfs. for (i = 0 ;i < n;i ++ ){ //如果城市没有被访问过（即visit[i]==0）而且两个城市之间是可连同的 if (visit[i] ==0&& dist[p][i] != INT_MAX){ visit[i] = 1 ; dfs(i,end,d + dist[p][i],team + countTeam[i]); visit[i] = 0 ; } } } 1004 Counting Leaves (30) A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. Input Each input file contains one test case. Each case starts with a line containing 0 < N < 100, the number of nodes in a tree, and M (< N), the number of non-leaf nodes. Then M lines follow, each in the format: ID K ID[1] ID[2] … ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID's of its children. For the sake of simplicity, let us fix the root ID to be 01. Output For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output \"0 1\" in a line. Sample Input 2 1 01 1 02 Sample Output 0 1 /** *题目的大概意思是求一棵树每层的没有孩子节点的节点数 **/ #include<stdio.h> /** *调用一个深度优先遍历的函数 **/ void dfs ( int ids, int level, int no[], int chil[][ 110 ], int node){ int i,flag =0 ; if (no[level] == -1 ) no[level] = 0 ; for (i = 1 ;i <= node;i ++ ){ if (chil[ids][i] ==1 ){ flag = 1 ; //递归调用,这里体现了是深度优先，遍历该ids的孩子i节点，在level+1层 if (level +1 <= node) dfs(i,level +1 ,no,chil,node); } } if (flag == 0 ) no[level] ++ ; } int main (){ int nochild[ 110 ],chi[ 110 ][ 110 ]; int n,m,i,j,id,child,son; // 初始化存贮每层没有孩子节点的节点总数，初始化二维数组代表每个i号节点所有的子节点编号，用j来记录子节点的编号，数组元素为1代表这个位置是有子节点 for (i = 0 ;i <= 100 ;i ++ ){ nochild[i] = -1 ; for (j = 0 ;j <=100 ;j ++ ){ chi[i][j] = 0 ; } } scanf( \"%d%d\" , & n, & m); for (i = 1 ;i <= m;i ++ ){ scanf( \"%d%d\" , & id, & child); for (j = 1 ;j <= child;j ++ ){ scanf( \"%d\" , & son); chi[id][son] = 1 ; } } dfs( 1 , 1 ,nochild,chi,n); for (i = 1 ;i <= n;i ++ ){ if (nochild[i] > -1&& i ==1 ) printf( \"%d\" ,nochild[i]); else if (nochild[i] > -1 ) printf( \" %d\" ,nochild[i]); } printf( \" \\n \" ); return 0 ; } 1005 Spell It Right (20) Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. Input Specification: Each input file contains one test case. Each case occupies one line which contains an N (<= 10100). Output Specification: For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input: 12345 Sample Output: one five #include<stdio.h> int main (){ char num[ 101 ]; //开一个字符数组101长度，可以存储题目要求的长最多101的整数 int sum = 0 ; char result[ 4 ]; char ten[ 10 ][ 10 ] = { \"zero\" , \"one\" , \"two\" , \"three\" , \"four\" , \"five\" , \"six\" , \"seven\" , \"eight\" , \"nine\" }; int i,a,b,c,d; scanf( \"%s\" ,num); for (i = 0 ;num[i] != '\\0' ;i ++ ){ sum = sum + (num[i] - '0' ); } if (sum >=0&& sum <=9 ){ printf( \"%s\" ,ten[sum]); } else if (sum >=10&& sum <=99 ){ a = sum /10 ; b = sum %10 ; printf( \"%s %s\" ,ten[a],ten[b]); } else { a = sum /10 ; c = sum %10 ; d = a; a = a /10 ; b = d %10 ; printf( \"%s %s %s\" ,ten[a],ten[b],ten[c]); } //for(i = 0;i<10;i++){ //printf(\"%s\\n\",ten[i]);} //printf(\"%s\\n\",sum); //printf(\"%d\\n\",sum); return 0 ; } 1006 Sign In and Sign Out (25) At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification: Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters. Output Specification: For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input: 3 CS301111 15:30:28 17:00:10 SC3021234 08:00:00 11:25:25 CS301133 21:45:00 21:58:40 Sample Output: SC3021234 CS301133 /* 基于时间的比较 */ #include<stdio.h> struct Record{ char ID[ 15 ]; //工号 int in; //sign in 时间 int out; //sign out 时间 }; int main (){ int m,i; struct Record p,p_in,p_out; //这边要记得加struct int h1,m1,s1,h2,m2,s2; scanf( \"%d\" , & m); if (m == 0 ) return 0 ; scanf( \"%s%d%*c%d%*c%d %d%*c%d%*c%d\" ,p.ID, & h1, & m1, & s1, & h2, & m2, & s2); p.in = h1 *3600+ m1 *60+ s1; //将时间转换为秒来进行比较 p.out = h2 *3600+ m2 *60+ s2; p_in = p_out = p; for (i = 1 ;i < m;i ++ ){ scanf( \"%s%d%*c%d%*c%d %d%*c%d%*c%d\" ,p.ID, & h1, & m1, & s1, & h2, & m2, & s2); // %*c代表忽略输入的这个字符 p.in = h1 *3600+ m1 *60+ s1; p.out = h2 *3600+ m2 *60+ s2; if (p.in < p_in.in) p_in = p; if (p.out > p_out.out) p_out = p; } printf( \"%s %s\" ,p_in.ID,p_out.ID); return 0 ; } 1007 Maximum Subsequence Sum (25) Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 <= i <= j <= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification: Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (<= 10000). The second line contains K numbers, separated by a space. Output Specification: For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input: 10 -10 1 2 3 4 -5 -23 3 7 -21 Sample Output: 10 1 4 /* 一开始我理解错了题目的意思，题目的意思是输出sum以及子序列的第一个值和最后一个值，而不是我理解的第一个下标和最后一个下标 */ #include<stdio.h> int main (){ int n,i,j,num[ 10000 ],count,sum,temp,start,end,a; //num数组一开始初始化为1024出错，要初始化为10000 count = 0 ; scanf( \"%d\" , & n); for (i = 0 ;i < n;i ++ ){ scanf( \"%d\" , & num[i]); if (num[i] >0|| num[i] == 0 ) count ++ ; } //如果所有的输入都是负数，就将和设为0，第一个数为第一个，最后一个数为最后一个，也可以映射出最后的和一定是大于等于0 if (count == 0 ){ printf( \"0 %d %d\" ,num[ 0 ],num[n -1 ]); return 0 ; } sum = -1 ; //一开始我将sum的初始值赋值成num[0]出错。 for (i = 0 ;i < n;i ++ ){ a = i; temp = 0 ; for (j = i;j < n;j ++ ){ temp = temp + num[j]; if (temp > sum){ sum = temp; start = num[a]; end = num[j]; } } } printf( \"%d %d %d\" ,sum,start,end); return 0 ; } 1008 Elevator The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop. For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled. Input Specification: Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100. Output Specification: For each test case, print the total time on a single line. Sample Input: 3 2 3 1 Sample Output: 41 /** *1008 **/ #include<stdio.h> #include<math.h> int main (){ int n,i,j,a[ 20000 ],D_value,time; a[ 0 ] = 0 ; time = 0 ; scanf( \"%d\" , & n); for (i = 1 ;i <= n;i ++ ){ scanf( \"%d\" , & a[i]); D_value = a[i] - a[i -1 ]; if (D_value >0 ){ time = time + D_value *6+5 ; } if (D_value <0 ){ time = time + abs(D_value) *4+5 ; } if (D_value == 0 ){ //这边不要忘记了，一开始没有加，如果还是本层有人要上的话，就要将时间再多停留5S time = time + 5 ; } } printf( \"%d\" ,time); } 1009 Product of Polynomials This time, you are supposed to find A*B where A and B are two polynomials. Input Specification: Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 <= K <= 10, 0 <= NK < … < N2 < N1 <=1000. Output Specification: For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 3 3.6 2 6.0 1 1.6 #include<stdio.h> #include<stdlib.h> typedef struct p1{ //这边的结构体必须要这样定义 int expo; double coe; }po; int main (){ int k1,k2,i,j,max,expo,count = 0 ; po * a, * b, * c; while (scanf( \"%d\" , & k1) != EOF){ a = (po * )malloc(k1 * sizeof (po)); //开辟空间给数组a for (i = 0 ;i < k1;i ++ ){ scanf( \"%d %lf\" , & a[i].expo, & a[i].coe); } scanf( \"%d\" , & k2); b = (po * )malloc(k2 * sizeof (po)); //开辟空间给数组b for (i = 0 ;i < k2;i ++ ){ scanf( \"%d %lf\" , & b[i].expo, & b[i].coe); } max = a[ 0 ].expo + b[ 0 ].expo; c = (po * )malloc((max +1 ) * sizeof (po)); //为最后的成绩结果分配max+1的空间，因为指数是按递减进行排列的，所以直接先求出最大的指数是多少 for (i = 0 ;i < max +1 ;i ++ ){ c[i].expo = i; c[i].coe = 0 ; } for (i = 0 ;i < k1;i ++ ){ for (j = 0 ;j < k2;j ++ ){ expo = a[i].expo + b[j].expo; c[expo].coe += a[i].coe * b[j].coe; //直接将指数作为下标，这样易于将指数相同的结合 } } for (i = 0 ;i <= max;i ++ ){ if (c[i].coe !=0 ) //这边算是考虑到了系数为0的情况 { count ++ ; } } printf( \"%d\" ,count); for (i = max;i >=0 ;i -- ){ if (c[i].coe !=0 ){ printf( \" %d %.1lf\" ,i,c[i].coe); } } } return 0 ; } 1010 Radix (25) Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is \"yes\", if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given. Input Specification: Each input file contains one test case. Each case occupies a line which contains 4 positive integers: N1 N2 tag radix Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set {0-9, a-z} where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number \"radix\" is the radix of N1 if \"tag\" is 1, or of N2 if \"tag\" is 2. Output Specification: For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print \"Impossible\". If the solution is not unique, output the smallest possible radix. Sample Input 1: 6 110 1 10 Sample Output 1: 2 Sample Input 2: 1 ab 1 2 Sample Output 2: Impossible #include<stdio.h> //有一个过不了 #define max 10240000 char N[ 3 ][max]; long long int radix,num1,tag; //将数字转化为长整型 long long int tolongint ( char s[max], long long int dig){ long long int ans =0 ; long long int d =1 ; int len =0 ; while (s[len] != '\\0' ){ len ++ ; } for ( int i = len -1 ;i >=0 ;i -- ) { int num; if (s[i] >= '0' && s[i] <= '9' ) num = s[i] - '0' ; else num = s[i] - 'a' +10 ; ans = ans + num * d; d *= dig; } return ans; } //比较如果以dig为奇数，另一个数化为长整型后与num1比较的大小 int cmp ( char s[max], long long int dig) { long long int ans =0 ; long long int d =1 ; int len =0 ; while (s[len] != '\\0' ){ len ++ ; } for ( int i = len - 1 ;i >=0 ;i -- ) { int num; if (s[i] >= '0' && s[i] <= '9' ) num = s[i] - '0' ; else num = s[i] - 'a' +10 ; ans = ans + num * d; if (ans > num1) return 1 ; d *= dig; } if (ans == num1) return 0 ; return -1 ; } //找出给出的数中最大的数字 int Maxnum ( char s[max]) { int d =-1 ; int len =0 ; while (s[len] != '\\0' ){ len ++ ; } for ( int i =0 ;i < len;i ++ ) { int num; if (s[i] >= '0' && s[i] <= '9' ) num = s[i] - '0' ; else num = s[i] - 'a' +10 ; if (num > d) d = num; } return d +1 ; } long long int Max ( long long int a, long long int b) { return a > b ? a :b; } //利用二分法来找基数 long long int BinarySearch ( int cur) { long long int L = Maxnum(N[cur]); long long int R = Max(L,num1),M; while (L <= R) { M = (L + R) /2 ; int res = cmp(N[cur],M); if (res ==0 ) return M; else if (res ==1 ) R = M -1 ; else L = M +1 ; } return -1 ; } int main (){ //long long int i,num,d=1; while (scanf( \"%s %s %lld %lld\" , & N[ 1 ], & N[ 2 ], & tag, & radix) != EOF){ if (N[ 1 ] == \"1\" && N[ 2 ] == \"1\" ) //1上面是\"\"而不是'' { printf( \"2 \\n \" ); continue ; } else if (N[ 1 ] == N[ 2 ]){ printf( \"%d \\n \" ,radix); continue ; } num1 = tolongint(N[tag],radix); int cur; if (tag ==1 ) cur =2 ; else cur =1 ; long long int ans = BinarySearch(cur); if (ans ==-1 ) printf( \"Impossible \\n \" ); else printf( \"%d \\n \" ,ans); } return 0 ; } 1011 World Cup Betting (20) With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets. Chinese Football Lottery provided a \"Triple Winning\" game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner's odd would be the product of the three odds times 65%. For example, 3 games' odds are given as the following: W T L 1.1 2.5 1.7 1.2 3.0 1.6 4.1 1.2 1.1 To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1 3.0 2.5 65%-1) 2 = 37.98 yuans (accurate up to 2 decimal places). Input Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L. Output For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space. Sample Input 1.1 2.5 1.7 1.2 3.0 1.6 4.1 1.2 1.1 Sample Output T T W 37.98 #include<stdio.h> struct game{ double W; double T; double L; }; int main (){ struct game bet[ 3 ]; int i =0 ,j =0 ,Mflag,mflag,sflag; double result =1 ,tmp,max; char tag[ 3 ] = { 'W' , 'T' , 'L' }; for ( i = 0 ;i != 3 ;i ++ ){ max = 0 ; int pos = -1 ; for (j = 0 ;j != 3 ;j ++ ){ scanf( \"%lf\" , & tmp); // if ((tmp - max) >1e-6 ){ max = tmp; pos = j; } } result *= max; printf( \"%c \" ,tag[pos]); } result = (result *0.65-1 ) *2 ; printf( \"%0.2f\" ,result); return 0 ; } 1012 The Best Rank (25) To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algebra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student. For example, The grades of C, M, E and A - Average of 4 students are given as the following: StudentID C M E A 310101 98 85 88 90 310102 70 95 88 84 310103 82 87 94 88 310104 91 91 91 91 Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average. Input Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (<=2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID. Output For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space. The priorities of the ranking methods are ordered as A > C > M > E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority. If a student is not on the grading list, simply output \"N/A\". Sample Input 5 6 310101 98 85 88 310102 70 95 88 310103 82 87 94 310104 91 91 91 310105 85 90 90 310101 310102 310103 310104 310105 999999 Sample Output 1 C 1 M 1 E 1 A 3 A N/A","tags":"misc","title":"PAT"},{"url":"http://sherryhaha.github.io/about/","text":"博客内容 欢迎来到我的博客［鼓掌］，在这里，我会纪录我的一些学习所得，一些生活心得，还有我的护肤心得［爱心］。 专业方面，由于我研究生方向是医学图像处理，所以以后这方面的内容会比较多。目前在学习python。 护肤方面，是我自己的一个小心愿，能将自己的实践告诉更多的人，当然，如果时间约束，可能不会经常更。 自我介绍 2012.8~至今： 就读苏州大学计算机科学与技术专业 2013.3~至今：进入苏州大学sklcc实验室 2015.9:保研入东南大学计算机学院，研究医学图像处理方向 交流 欢迎各位与我交流～～","tags":"misc","title":"About"},{"url":"http://sherryhaha.github.io/bo-wu-guan-mei-ti-zhan-cheng-xiang-mu-jie-shao/","text":"what you see is what you can get more 背景介绍 随着数字化与博物馆的碰撞，越来越多数字博物馆交互式鉴赏平台得以呈现，我们所做的这个小项目，是想让观光博物馆的人通过手机摄像头观看文物时，可以得到更多相关动态有趣的内容以及相应的语音讲解。 研究方案 此项目采用 CS （ Client-Server ）架构实现，客户端通过摄像头获取实时帧将图片传送给服务器，服务器获取图片后对其进行图像匹配处理，返回给客户端相对应的视频地址，客户端获取视频地址后进行全屏播放。 服务器端，需要事先存储好视频，以及每个视频对应的关键帧。 Client ： iOS 版和 android 版本 Server ：采用 java-struts 框架 开发难点 图像匹配算法的选择 第一、二周，寻找各种图像匹配算法，其中被我们实验过的有 - SIFT （ Sacle-invariant Feature Transform ）算法 - 感知哈希算法 - 均值哈希算法 - surf 算法 其中我个人认为比较好用的是 SIFT 算法和 感知哈希算法 ，尤其是感知哈希算法，它的实时性占很大优势，但在匹配的准确度上不够精确。接下来分别简要阐述一下 SIFT 、感知哈希和均值哈希的算法步骤。 Lowe (作者)将 SIFT 算法分解为如下四步： 尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。 关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。 方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。 关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。 感知哈希 phash 比均值哈希要稳健， phash 使用了 DCT 来降低频率。感知哈希算法可分为以下几个步骤： 将图片缩小32*32最好，这样可以简化DCT计算。 将图片色彩简化为灰度图像。 计算DCT，使用32*32的DCT变换。 DCT的结果是32 32的矩阵，只要保留左上角的8 8矩阵就可以了，因为这部分呈现了图片中的最低频率。 计算DCT的平均值。 根据8*8的DCT矩阵来与平均值进行比较，大于平均值的为1，小于的为0。 构造图片矩阵。 均值哈希 的步骤： 先将图片缩小尺寸为8*8的正方形，64个像素。 将图片的色彩简化为灰度图像。 计算64个像素的灰度平均值。 将每个像素的灰度值与平均值进行对比，若大于平均值，即为1，小于平均值即为0。 将上一步得到的64个值组成的称为这个图片的指纹。 若要比较两个图片，就将第五步得到的进行比较，计算不同位的个数。 研究成果 概述 实现 android 、 iOS 客户端获取、上传图片到服务器 实现服务器对客户端上传的图片进行图像匹配并返回视频地址 实现客户端通过返回的视频地址自动全屏播放视频 分别采用不同的图像匹配算法进行验证 待优化的问题 android 端目前采用的是拍照上传的模式而并非获取实时帧，可以对其获取图片的方式进行改进真正达到 what you see is what you can get more 的实时获取。 图像匹配算法的优化，目前实现的算法并没有具备实时性与准确性。 SIFT 算法由于要提取特征点、进行特征点匹配等复杂的动作，使得其实时性达不到要求。感知哈希对于图片匹配的准确性有待提高。我个人觉得后期可采取利用大量图片进行试验，从而根据实际需求选择最为适合的算法 对于每一个视频提取关键帧的方法以及关键帧的存贮方式。 本项目应用价值 摆脱盲目逛景点困扰，通过摄像头可以看到、听到生动形象的视频与讲解。 数字化与博物馆的碰撞，不仅改变了以往人们逛博物馆的方式，也丰富了人们可以获得信息量。","tags":"项目","title":"博物馆媒体展呈项目介绍"},{"url":"http://sherryhaha.github.io/pai-xu/","text":"@(刷题生活) 排序方法 选择排序 ： 低效，n平方`` 不稳定 扫描整个列表找出最小值，将它与列表第一个位置的值交换 扫描剩余部分的列表，找出最小值，与该列表第二个位置处的值交换 对列表中的每一个位置继续使用该过程 插入排序 ： 低效 n平方 稳定 对列表的头两个值进行排序，将第三个值插入到前两个值的恰当位置，将第四个值插入到列表前三个值的恰当位置...... void insertSort ( int data[], int len){ for ( int index = 1 ;index < len;index ++ ){ int key = data[index]; int position = index; while (position > 0&& data[position -1 ] > key){ data[position] = data[position -1 ]; position -- ; } data[position] = key; } } 冒泡排序 ： 低效 n平方 稳定 扫描列表邻接元素，如果不是按照相对顺序排列则将他们交换，每经过一轮，冒泡排序算法都会将最大值移到最终的位置 快速排序 ： 高效 nlogn 不稳定 是所有排序算法中最高效的一种，采用了分治的思想：先保证列表的前半部分都小于后半部分，然后再对前半部分和后半部分排序，这样整个列表就有序了。 void quickSort ( int data[], int low, int high){ if (low < high){ //create partition int indexofpartition = partition(data,min,max); //sort the left partition quickSort(data,min,indexofpartition - 1 ); //sort the right partition quickSort(data,indexofpartion + 1 ,max); } } int partition ( int data[], int low, int high){ int partitiononelement; int left,right; int middle = (min + max) /2 ; //using the middle data as the partition element partitiononelement = data[middle]; swap(data,middle,low); left = low; right = high; while (left < right){ //search an element that is big than the partition element while (left < right && data[left] <= partitiononelement){ left ++ ; } //search an element that is small than the partition element while (data[right] > partitiononelement){ right -- ; } if (left < right){ swap(data,left,right); } } swap(data,low,right); return right; } void swap ( int data[], int a, int b){ int tmp; tmp = data[a]; data[a] = data[b]; data[b] = tmp; } 归并排序（merge sort） nlog2n最坏 稳定 将列表分成两个大约相等的部分，对每一个部分递归调用其自身。继续该列表的递归分解，直至达到该递归的基本情形，这时该列表被分割成长度为1的列表，然后随着程序控制权传回至该递归调用结构，该算法将两个递归调用所产生的那两个排序子列表归并为一个排序列表。 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。若要求排序稳定，则可选用归并排序。 查找 线性顺序查找 二分查找 int Search ( int a[], int key, int len){ int low = 0 ,hight = len - 1 ,mid; while (low <= high){ mid = (low + high) /2 ; if (a[mid] == key) return mid; else if (a[mid] < key) low = mid + 1 ; else high = mid - 1 ; } return -1 ; //没有找到的时候 } 哈希查找 哈希查找的操作步骤： 1) 用给定的哈希函数构造哈希表； 2) 根据选择的冲突处理方法解决地址冲突； 3) 在哈希表的基础上执行哈希查找。 Hash 表检索数据 int searchHash( int hash[], int hashLength, int key){ int hashAddress = key % hashLength; if (hash[hashAddress] !=0&& hash[hashAddress] != key){ hashAddress = ( ++ hashAddress) % hashLength; } if (hash[hashAddress] == 0 ){ return -1 ; } else { return hashAddress; } } //数据插入hash表 void insertHash( int hash[], int hashLength, int data){ int hashAddress = data % hashLength; while (hash[hashAddress] !=0 ){ //用开放寻址找 hashAddress = ( ++ hashAddress) % hashLength; } hash[hashAddress] = data; } tips - strlen可以用来求字符数组的长度，不可以用来求整数数组的长度，它是找到'\\0'来标记结束，但是整数的0就会是'\\0' - sizeof(data)/sizeof(int)求的是数组长度。如data[200]求出来就是200，不会在意里面真实有多少。","tags":"刷题","title":"排序"},{"url":"http://sherryhaha.github.io/balanced-binary-tree/","text":"问题描述： Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 用了两个递归，一个递归来判断是否是平衡树，一个递归用来求左右子树的高度。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int getHeight ( struct TreeNode * root){ if (root == 0 ) return 0 ; int L,R; L = getHeight(root -> left); R = getHeight(root -> right); if (L < R) return R + 1 ; else return L + 1 ; } bool isBalanced ( struct TreeNode * root) { if (root == NULL ) return true ; struct TreeNode * left = root -> left; struct TreeNode * right = root -> right; int diff; diff = getHeight(left) - getHeight(right); diff = abs(diff); if (diff >1 ) return false ; return isBalanced(left) && isBalanced(right); }","tags":"刷题","title":"Balanced Binary Tree"},{"url":"http://sherryhaha.github.io/container-with-most-water/","text":"Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. 题意大概是：给一个数组height[n]，其中每一个元素height[i]=num,i代表它的横坐标，num代表纵坐标，要求由这个数组任意两个元素围成的面积最大的。 可以想象，如果最大由【i，j】对应构成，假设i<j,那么，i左边的所有元素高度都应当小于i 对应的高度，j右边所有元素高度都应该低于j对应的高度。所以可以从数组两边开始收缩，高度小的那边开始向中间收缩，直到找到一个高度比它高的才停止。 int maxArea ( int * height, int heightSize) { int maxarea = -1 ,area,head =0 ,tail = heightSize -1 ,p; while (head < tail){ area = (height[head] < height[tail] ? height[head] : height[tail]) * (tail - head); maxarea = maxarea > area ? maxarea :area; if (height[head] < height[tail]){ p = head; while (head < tail && height[head] <= height[p]) head ++ ; } else { p = tail; while (head < tail && height[tail] <= height[p]) tail -- ; } } return maxarea; }","tags":"刷题","title":"Container With Most Water"},{"url":"http://sherryhaha.github.io/count-primes/","text":"Count the number of prime numbers less than a non-negative number, n. 问题解析：最容易想到的办法就是内循环判断是不是素数，外循环判断每一个小于n的数字，但是这样的话会超时，并不符合时间要求。 然后到网上看到了一种筛选素数的方法： 埃拉托斯特尼筛法 详细列出算法如下： 列出2以后的所有序列： 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 标出序列中的第一个素数，也就是2，序列变成： 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 将剩下序列中，划掉2的倍数（用红色标出），序列变成： 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 如果现在这个序列中最大数小于最后一个标出的素数的平方，那么剩下的序列中所有的数都是素数，否则回到第二步。 本例中，因为25大于2的平方，我们返回第二步： 剩下的序列中第一个素数是3，将主序列中3的倍数划出（红色），主序列变成： 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 我们得到的素数有：2，3 25仍然大于3的平方，所以我们还要返回第二步： 现在序列中第一个素数是5，同样将序列中5的倍数划出，主序列成了： 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 我们得到的素数有：2 3 5 。 因为25等于5的平方，跳出循环. 结论：去掉红色的数字，2到25之间的素数是：2 3 5 7 11 13 17 19 23。 int countPrimes ( int n) { int * prime = ( int * )malloc( sizeof ( int ) * n); int i,j,num,count =0 ; if (n <=2 ){ return 0 ; } for (i = 2 ;i < n;i ++ ){ prime[i] = 1 ; } i = 2 ; while (i * i < n){ for (j = 2 ,num = i *2 ;num < n;num = j * i, ++ j){ // printf(\"%d\\n\",num); prime[num] =0 ; } do { i ++ ;} while (i * i < n && prime[i] ==0 ); } for (i =2 ;i < n;i ++ ){ if (prime[i] ==1 ){ count ++ ; } } return count; }","tags":"刷题","title":"Count primes"},{"url":"http://sherryhaha.github.io/happy-number/","text":"A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 此题有两个关键，一个是如何将一个数一位一位的拆开进行平方和求解。一个是如何较为快速的判断在这个过程中有没有出现循环，或平方和是不是1。 c语言版本 对于求解一个数的各位平方和，可以采用一直除10取余数的方法，对于happy number的判断，我还是采用了哈希表的方法，就是将每一次的平方和放入哈希表中，当然在放的时候先检查一下，该数值是否为1，为1就直接返回true，证明这个数是个happy number.还要判断一下这个数是否在哈希表中已经存在了，如果已经存在了就不要放入哈希表中，并且返回false,因为说明结果产生了循环。 bool isHappy ( int n) { int hash[ 1024 ],hashlength =1024 ,hashAddress1,sum =0 ; memset(hash, -1 , sizeof (hash)); while (sum !=1 ){ //计算一个整数各个位的和,sum的值就是和值。 while (n >0 ){ sum += (n %10 ) * (n %10 ); n = n /10 ; } if (sum == 1 ){ return true ; } //将值映射到哈希表上 hashAddress1 = sum % hashlength; if (hash[hashAddress1] == sum){ return false ; } while (hash[hashAddress1] !=-1 ){ hashAddress1 = ( ++ hashAddress1) % hashlength; if (hash[hashAddress1] == sum){ return false ; } } hash[hashAddress1] = sum; n = sum; sum = 0 ; } } java版本 跟c的思路一样，只是java有HashSet接口，所以写起来没c麻烦. 所以我正好学习了一下HashSet 。HashSet是基于HashMap实现的，HashSet底层采用HashMap来保存所有的元素。所以放入HashSet中的集合元素实际上是由HashMap的Key来保存，而HashMap的value存储了一个PRESENT，是一个静态的Object对象。 public boolean isHappy ( int n ) { long ln = n ; Set < Long > set = new HashSet < Long >(); long sum = 0; while ( sum !=1){ sum = 0; while ( ln >0){ //求ln%10的平法 sum += Math . pow ( ln %10, 2); ln = ln /10; } if ( sum == 1){ return true ; } //检查集合中是否已经存在sum if ( set . contains ( sum )){ return false ; } set . add ( sum ); ln = sum ; } return false ; } 更精短的c语言实现方法 利用的是一个fact：所有[2,6]的数字都不是happy number,还有一个数学发现就是，所有不以1结束的数字，都会以4结束无尽循环，（4->16->37->58->89->145->42->20->4）所谓的快乐数与不快乐数，都只是数学家们观察而发现的，现在还没有什么用处，也没有证明。以下就是用上述事实来进行的程序判断 bool isHappy ( int n) { while (n >6 ){ int sum = 0 ; while (n){ sum += (n %10 ) * (n %10 ); n /=10 ;} n = next; } return n ==1 ; }","tags":"刷题","title":"Happy Number"},{"url":"http://sherryhaha.github.io/minimum-depth-of-binary-tree/","text":"Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 求一颗二叉树的最小深度。当二叉树只有一个节点时，它的深度是为1. 可以用递归求，求分别递归求左子树与右子树的深度，然后比较深度小的那个加一，值得注意的是，当一个节点，只有左子结点（或只有右子节点）时，这时他并不是一个叶子节点，还需要向下继续求深度，所以右子节点不能返回一个比左子结点求出的深度小的值，就付给他一个较大的值就可以了。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int minDepth ( struct TreeNode * root) { int leftdepth ,rightdepth; if (root == NULL ) return 0 ; if (root -> left == NULL && root -> right == NULL ) return 1 ; else { if (root -> left != NULL ) { leftdepth = minDepth(root -> left); } else leftdepth = 1000000 ; if (root -> right != NULL ) {rightdepth = minDepth(root -> right);} else rightdepth = 1000000 ; } if (leftdepth > rightdepth) { return rightdepth +1 ; } else { return leftdepth +1 ; } } 知识普及 maxheight函数就是求二叉树的左子树与右子树中那个深度最大最大深度多少，minheight函数就是求二叉树的左子树与右子树中那个深度最小最小深度多少，Isbalance函数就是求左子树与右子树的深度差，只要不大于1就是平衡二叉树。 平衡二叉树:它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。","tags":"刷题","title":"Minimum Depth of Binary Tree"},{"url":"http://sherryhaha.github.io/palindrome-linked-list/","text":"问题描述：判断一个单链表是否是回文，即正着读和反向读是一样的 问题分析： 采用c语言书写，首先找到链表的中间节点，然后将中间节点以后的反转，比较两个半链表是否一样。 struct ListNode { int val; struct ListNode * next; }; //找中间节点，利用快指针和慢指针来控制 struct ListNode * getMid ( struct ListNode * head) { // at least two nodes struct ListNode * slow = head; struct ListNode * fast = head; struct ListNode * preslow = head; //控制偶数链表时返回中间的第二个节点 while (fast != NULL && fast -> next != NULL ){ fast = fast -> next -> next; preslow = slow; slow = slow -> next; } preslow -> next = NULL ; return slow; } //反转链表 struct ListNode * reverse ( struct ListNode * head) { if (head == NULL || head -> next == NULL ) return head; else if (head -> next -> next == NULL ) { // two nodes struct ListNode * tail = head -> next; head -> next = NULL ; tail -> next = head; return tail; } else { struct ListNode * pre = head; struct ListNode * cur = pre -> next; pre -> next = NULL ; // set tail struct ListNode * post = cur -> next; while (post) { cur -> next = pre; pre = cur; cur = post; post = post -> next; } cur -> next = pre; return cur; } } bool isPalindrome ( struct ListNode * head) { if (head == NULL || head -> next == NULL ) return true ; struct ListNode * mid, * h1, * h2; mid = getMid(head); h2 = reverse(mid); h1 = head; while (h1 && h2){ if (h1 -> val != h2 -> val) return false ; else { h1 = h1 -> next; h2 = h2 -> next; } } return true ; }","tags":"刷题","title":"Palindrome Linked List"},{"url":"http://sherryhaha.github.io/reverse-linked-list/","text":"Reverse a singly linked list. 这是个简单的问题，主要考察的是对于链表的操作，并没有涉及算法什么的。让我正好温习了一下c 中链表的处理。 要翻转链表，首先考虑空元素，一个元素和两个元素的情况。然后用三个指针分别指向已经翻转部分的头pre，目前正呆处理的cur，还有cur的下一个，然后将cur的next指向pre，让pre等于cur,cur=post,post = post->next，这样依次往后移动进行处理。 struct ListNode { int val; struct ListNode * next; }; struct ListNode * reverseList ( struct ListNode * head) { //注意定义的时候不能少了struct，我一开始就是没有struct从而没有ac. struct ListNode * pre, * cur, * post; if (head == NULL || head -> next == NULL ){ return head; } if (head -> next -> next == NULL ){ ListNode * newhead = head -> next; newhead -> next = head; head -> next = NULL ; return newhead; } else { pre = head; cur = pre -> next; pre -> next = NULL ; post = cur -> next; cur -> next = pre; while (post != NULL ){ pre = cur; cur = post; post = post -> next; cur -> next = pre; } return cur; } }","tags":"刷题","title":"reverse Linked list"},{"url":"http://sherryhaha.github.io/two-sum/","text":"问题描述 hash Array Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 c语言解决 ： 由于这个问题有时间上的限制，我一开始想到的是用双重循环，外循环num2=target-nums[i]，然后再内循环从i+1一直找到数组的尾部寻找有没有num2 的存在，这样的时间复杂度是n&#94;2，没有被AC。 然后我看到题目的标签提示是hash，就去网上学了一下hash. 哈希表是基于快速存取设计的，是典型的 空间换时间 ，此数据结构可以理解为一个线性表，但其中的元素不是紧密排列的，存在空隙。哈希表是根据关键值直接进行访问的数据结构。是通过将关键值映射到表中一个位置进行访问，加快查找速度。所以做题思路就是先根据nums[]构建一个哈希表，然后再哈希表中查找num2. 构建哈希表的复杂度是n，查找的复杂度是1. int * twoSum ( int * nums, int numsSize, int target) { int i =0 ,num1,num2; int hashAddress1,hashAddress2; int hashlength =102400 ; int hash[ 102400 ]; //将数组的所有元素初始化为-1. memset(hash, -1 , sizeof (hash)); int * p; p = ( int * )malloc( 2* sizeof ( int )); //判断输入的数组不为空且多于一个元素 if (nums == NULL || numsSize <2 ){ return NULL ; } //构建哈希表 for (i =0 ;i < numsSize;i ++ ){ hashAddress1 = abs(nums[i]) % hashlength; //如果产生了冲突，就用线性探测法来解决 while (hash[hashAddress1] !=-1 ){ hashAddress1 = ( ++ hashAddress1) % hashlength; } hash[hashAddress1] = i; } //查找哈希表 i =0 ; while (i < numsSize){ num1 = nums[i]; num2 = target - nums[i]; hashAddress2 = abs(num2) % hashlength; while ((hash[hashAddress2] !=-1 && nums[hash[hashAddress2]] != num2) || (i == hash[hashAddress2])){ hashAddress2 = ( ++ hashAddress2) % hashlength; } if (hash[hashAddress2] ==-1 ) { i ++ ; continue ; } if (hash[hashAddress2] > i){ p[ 0 ] = i +1 ; p[ 1 ] = hash[hashAddress2] +1 ; break ; } } return p; } java版 java中有map接口，真是太好用了。用HashMap来实现。用HashMap来存储数组中的值和index.HashMap中查询键值对的开销是固定的，因此在性能上得到很大的提升。 该题中应用数组的值来做index索引来检索index。 public class Solution { public int [] twoSum ( int [] nums , int target ) { //声明哈希表 Map map = new HashMap (); int [] res = new int [2]; //创建哈希表 for ( int i = 0; i < nums . length ; i ++){ map . put ( nums [ i ], i ); } //查找哈希表，注意得到的index1不能等于index2 for ( int i = 0; i < nums . length ; i ++){ int numb = target - nums [ i ]; if ( map . get ( numb )!= null && ( int ) map . get ( numb )!= i ){ res [0] = i + 1; res [1] = ( int ) map . get ( numb )+1; break ; } } return res ; } }","tags":"刷题","title":"Two Sum"},{"url":"http://sherryhaha.github.io/yong-shi-kan-long-tou-wen-ti/","text":"问题描述：你的王国里有一条n个头的恶龙，可以雇佣骑士把它杀死，村里有m个骑士，能力值为x的骑士可以砍掉一个恶龙直径不超过x的头，且需支付金币x，怎样才能杀死恶龙并且支付金币最少？(一个骑士只能砍一个头，雇佣一次） 【格式输入】 每组数据的第一行为 n,m。下面n行每行为一个整数，代表恶龙头的直径，以下m行每行为一个整数，代表每个骑士的能力，输入结束标志是n=m=0。 【样例输入】 2 3 5 4 7 8 4 2 1 5 5 10 0 0 【样例输出】 11 Loowater is doomed! 问题解答：将骑士按能力从大到小排序，头的直径也按从大到小排序，一个一个的砍。 #include<stdio.h> #include<algorithm> using namespace std; const int maxn = 20000 ; int main (){ FILE * fp; //一个数组用来装头的直径，一个数组用来装骑士的能力 int A[maxn],B[maxn],n,m,i,cur ,cost ; if ( NULL == (fp = fopen( \"a.txt\" , \"r\" ))) { puts( \"error!\" ); return -1 ; } while (fscanf(fp, \"%d%d\" , & n, & m) == 2 && n && m){ cost = 0 ; //这边切记要置为0，因为每次循环都是一组新的数据 cur = 0 ; for (i = 0 ;i < n;i ++ ) fscanf(fp, \"%d\" , & A[i]); for (i = 0 ;i < m ;i ++ ) fscanf(fp, \"%d\" , & B[i]); sort(A,A + n); sort(B,B + m); for (i = 0 ;i < m;i ++ ){ if (B[i] >= A[cur]){ cost += B[i]; if ( ++ cur == n) break ; //如果所有的头都砍完了就退出循环 } } //如果还有头没砍完，则证明无解。 if (cur < n) printf( \"Loowater is doomed! \\n \" ); else printf( \"%d \\n \" ,cost); } return 0 ; }","tags":"刷题","title":"勇士砍龙头问题"},{"url":"http://sherryhaha.github.io/zigzag-conversion/","text":"The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\". 解题思路 所谓的 zigzag就是将一个字符串，按照z字形重新排列，再按行输出。但是可以发现一个规律，在组成 z形后，第一行与最后一行每相邻的两个元素间的间隔是2 (n-1) n是规定的将这个字符串分成几行。其他行的规律是，每两个元素间按照2 (n-i-1)和2*i的规律间隔变化。 char * convert ( char * s, int numRows) { char * result; int size = strlen(s); result = ( char * )malloc((size +1 ) * sizeof ( char )); char * p = result; int i =0 ,j; int r = 0 ; //如果要形成的z型行数为1或者数组的总长度少于要分成的行数则可以直接返回数组 if (numRows <= 1|| size <= numRows || s == NULL ){ return s; } for (i =0 ;i < numRows;i ++ ){ j = i; r = 0 ; //一开始由于这里我没有归零，而老是发生rumtime erro的错误。每次循环都要置为0，r代表每行中第几列。 while (j < size){ * (p ++ ) = s[j]; if (i ==0|| i == numRows -1 ){ j +=2* (numRows -1 ); } else if (i >=1|| i < numRows -1 ) { //交替出现 if (r %2==0 ) { j +=2* (numRows - i -1 ); } else { j +=2* i; } r ++ ; } } } * p = '\\0' ; return result; } malloc可以动态的分配数组的大小，但是记得用完以后要将它free掉，不然会内存泄露。 关于c中的指针 好久不写 C对指针这方面生疏许多，就翻书看了看。一个指针p是指一个地址，*p是指针变量p所指向的变量的值。 本程序中使用了指针p来引用数组，事先，p指向数组result的第一个元素，随着++逐渐向后推移。","tags":"刷题","title":"zigzag Conversion"},{"url":"http://sherryhaha.github.io/javaxue-xi/","text":"阅读了知乎上一些关于学习java的建议 大多都是建议要先学习好java SE(standard Edition)，是基于JDK（没有它无法编译java程序）与JRE（java运行环境） 可以先模仿着别人的代码，但一定要写，自己背着写。 任何事情都要追求完美才敢继续往后进行是一种性格缺陷 正则表达式的学习 @(正则表达式)[2015/3/8] 在java 中，有关于正则表达式的包是java.util.regex,它下面包含两个类Matcher与Pattern。一些具体参数或用法，都可以参展java的说明文档 从昨天开始在观看网上马士兵老师的java教程视频，学习正则表达式的使用。其中比较实用的应用就是可以抓取一个网页上特定格式的东西，如所有的email。叫做emailSpider。以下是实现配对的主要函数： private static void parse ( String line ) { /*从文件中一行一行的读取数据，在每一行中匹配具有email格式的字符串*/ Pattern p = Pattern . compile ( \"[\\\\w[.-]]+@[\\\\w[-.]]+\\\\.[\\\\w]+\" ); Matcher m = p . matcher ( line ); while ( m . find ()) { System . out . println ( m . group ()); } } Pattern 将给定的正则表达式编译并赋予给Pattern类。 生成 Matcher 实例，形象化不深入的肤浅可以理解为，Pattern对正则表达式进行编译，Matcher对它进行匹配。 利用正则表达式来计算一个java程序中总共有多少行代码，多少注释，多少空行。 其中主要的核心代码是一个函数，利用正则表达式来匹配这些可能性的行 private static void parse ( File child ) { BufferedReader br = null ; Boolean comment = false ; try { br = new BufferedReader ( new FileReader ( child )); String line = \"\" ; while (( line = br . readLine ())!= null ){ /*去除字符串头部与尾部的空格*/ line = line . trim (); /*匹配空白的行*/ if ( line . matches ( \"&#94;[\\\\s&&[&#94;\\\\n]]*$\" )){ whiteLines ++; } /*匹配注释行*/ else if ( line . startsWith ( \"/*\" )&&! line . endsWith ( \"*/\" )){ commentLines ++; comment = true ; } if ( true == comment ){ commentLines ++; if ( line . endsWith ( \"*/\" )){ comment = false ; } } else { normalLines ++; } } } catch ( FileNotFoundException e ) { e . printStackTrace (); } catch ( IOException e ) { e . printStackTrace (); } finally { if ( br != null ){ try { br . close (); br = null ; } catch ( IOException e ){ e . printStackTrace (); } } } JDBC JDBC 叫做 java Database Connectivity 是 J2EE 的一部分。 JDBC不同数据库有不同的对应类库。 JDBC 编程步骤： 1、通知DriverManager要连那种数据库，找到连接数据库的驱动包， java web 提交表单的处理 Step1: 编写index.jsp文件 代码如下： <%@ page pageEncoding = \"GBK\" %> <!DOCTYPE html> <html> <body> <p> 请输入数字。。 </p> <script> function validate_required(field,alerttxt) { with (field) { var x=document.getElementById(\"demo1\").value; if (isNaN(x)||x==\"\") {alert(alerttxt);return false;} else {return true;} } } function myFunction(thisform) { with(thisform){ if(validate_required(demo,\"输入数字可以嘛！\")==false) { demo.focus(); return false; } } } </script> <form action=\"welcome\" name = \"formtest\" method =\"post\" onsubmit=\"return myFunction(this);\" > <input id=\"demo1\" type=\"text\" name=\"demo\" > <input type=\"submit\" value=\"Submit\" > </form> </body> </html> welcome是对表单进行处理的Servlet,表单采用的提交方式是post.采用了一个函数来判断用户输入是否为数字，如果包含其他，就跳出警示窗口。 Step2:编写HelloServletFromMyEclipse.java 代码如下： public class HelloServletFromMyEclipse extends HttpServlet { public HelloServletFromMyEclipse () { super (); } public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( \"text/html\" ); PrintWriter out = response . getWriter (); out . print ( \"欢迎来这里呀\" ); } public void doPost ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { req . setCharacterEncoding ( \"gb2312\" ); PrintWriter out = resp . getWriter (); resp . setContentType ( \"text/html;charset=gb2312\" ); String name = java . net . URLDecoder . decode ( req . getParameter ( \"demo\" ), \"utf-8\" ); out . println ( \"myprintis\" + name ); Pattern p = Pattern . compile ( \"&#94;\\\\d+$\" ); Matcher m = p . matcher ( name ); if ( m . matches ()) { out . println ( \"true\" ); } else { out . println ( \"false\" ); } } } 通过req.getParameter(\"demo\")获得用户输入的信息，\"demo\"必须与表单中用于输入信息的文本区的demo一样。获得用户之后用正则来匹配是否为数字 Step3:部署Servlet 修改web.xml文件 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\" > <servlet> <servlet-name> HelloServlet </servlet-name> <servlet-class> com.bjsxt.servlet.HelloServletFromMyEclipse </servlet-class> </servlet> <servlet-mapping> <servlet-name> HelloServlet </servlet-name> <url-pattern> /welcome </url-pattern> </servlet-mapping> <welcome-file-list> <welcome-file> index.html </welcome-file> <welcome-file> index.htm </welcome-file> <welcome-file> index.jsp </welcome-file> <welcome-file> default.html </welcome-file> <welcome-file> default.htm </welcome-file> <welcome-file> default.jsp </welcome-file> </welcome-file-list> </web-app> 统计页面被访问的次数 主要代码 public void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { ServletContext context = getServletContext (); Integer count = ( Integer ) context . getAttribute ( \"counter\" ); if ( null == count ){ count = new Integer (1); } else { count = new Integer ( count . intValue ()+1); } resp . setContentType ( \"text/html;charset=gb2312\" ); PrintWriter out = resp . getWriter (); out . println ( \"<HTML>\" ); out . println ( \" <HEAD><TITLE>页面访问统计</TITLE></HEAD>\" ); out . println ( \" <BODY>\" ); out . print ( \"该页面被访问了：\" + \"<b>\" + count + \"</b>\" + \"次\" ); out . println ( \" </BODY>\" ); out . println ( \"</HTML>\" ); context . setAttribute ( \"counter\" , count ); out . flush (); out . close (); } 通过getServletContext()的方法得到web应用程序的上下文对象。通过getAtrribute()方法获取属性counter的值，判断counter是否为空，为null就将它的初始值设为1，当servlet第一次被访问，设为1，以后再被访问就是加一，将count作为counter的属性保存到ServletContext对象中。 问题 在用jsp连接数据库时出现连接不了数据库的现象，一直查不出什么原因，后来借鉴网友意见，把驱动包添加到WEB_INF下的lib中，就好了== 在web客户端的三种语言 @(2015/3/17) html(hyper text markup language),css,javascript是web客户端的三种语言，其中javascript即可被用在客户端，也可以被用在服务器端，主要是用在客户端。 html meta 是元数据，描述文档本身的信息 <meta http-equiv=\"refresh\" content =\"3;url=\"http: // www . baidu . com \" > 每隔3秒刷新当前页面到www.baidu.com <meta http-equiv=\"content-type\" content =\"text/html;charset=gb2312\" > 当前页面是html格式，编码是gb2312 <meta http-equiv=\"expires\" content =\"0\" > 告知浏览器不要对本网页进行缓存 <meta http-equiv=\"pragma\" content =\"no-cache\" > 不要在代理服务器上缓存 <meta name=\"author\" content =\"sgy\" > 作者 <meta name=\"copyright\" content =\"do not use this page without my permission\" > 版权声明","tags":"java学习","title":"JAVA学习"}]}